---
title: "Randomization Inference with *permuter*"
author: "Dustin J. Rabideau"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Randomization Inference with permuter}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The **permuter** package was developed to carry out randomization inference for a treatment effect in cluster randomized trials (Rabideau and Wang, 2019). In this vignette, we introduce the package and illustrate some of its functionality using two examples.

## Introduction
The **permuter** package contains various functions to calculate p-values and confidence intervals (CIs) for common regression models using randomization (or randomization-based, permutation) inference. For example, `permtest_glm` and `permci_glm` correspond to `stats::glm`; `permtest_coxph` and `permci_coxph` correspond to `survival::coxph`. Much of the syntax and arguments are kept consistent between the randomization-based functions and their counterparts. For example, to fit a simple logistic regression model, we could use
```{r, intro1, eval = F}
glm(outcome ~ exposure, family = binomial, data = ds)
```
To carry out randomization inference for this model, we instead use
```{r, intro2, eval = F}
permtest_glm(outcome ~ exposure, family = binomial, data = ds, ...)
permci_glm(outcome ~ exposure, family = binomial, data = ds, ...)
```
There are a few necessary (and other optional) arguments in `...` that we specify for the randomization-based functions (more on this later), but the basic formulation should be familiar. One optional argument worth mentioning here is `ncores`, which allows us to carry out randomization inference in parallel across multiple cores using functionality from [**doParallel**](https://cran.r-project.org/web/packages/doParallel/index.html) and [**doRNG**](https://cran.r-project.org/web/packages/doRNG/index.html). E.g. we can specify `permtest_glm(..., ncores = 3)` to run the randomization test in parallel across 3 cores.

## Example 1: The Basics
The Pneumococcal Conjugate Vaccine Trial was a cluster randomized trial carried out from 1997 to 2000 to assess the safety and efficacy of a seven-valent conjugate pneumococcal vaccine (O'Brien et al., 2003). The study population was Navajo and White Mountain Apache children younger than 2 years, a group with one of the highest documented rates of invasive pneumococcal disease in the world at that time. A total of 38 geographic areas were randomized: 19 areas were offered pneumococcal vaccine and 19 were offered a comparator (meningococcal vaccine). One individual-level outcome measured during the trial was the total number of bacterial pneumonia episodes experienced by each child during follow-up. We will analyze this count outcome for a random subsample of 449 children drawn from the original 8,292 trial participants (Hayes and Moulton, 2017). These data are available in the **permuter** package and [here](https://dataverse.harvard.edu/dataverse/crt) on Harvard Dataverse.

The `pneumovac` data frame contains columns for the individual-level count outcome (`bpepisodes`), an indicator of randomization to the pneumococcal vaccine (`spnvac`), and a distinct identifier for each geographic area (`randunit`) and individual (`fakeid`). 
```{r, data}
library(permuter)
head(pneumovac)
```

#### Randomization test
Let's use randomization inference to determine whether there was a difference in the rate of bacterial pneumonia episodes between the two intervention groups. The test statistic we will use is the estimated log incidence rate ratio (IRR) from a Poisson generalized linear model (GLM). Let's calculate the p-value based on 1,000 permutations. To carry out this randomization test, we'll use the `permtest_glm` function in the **permuter** package.
```{r, ptest, warning = F}
test <- permtest_glm(formula = bpepisodes ~ spnvac, 
                     trtname = 'spnvac', runit = 'randunit', family = poisson, 
                     data = pneumovac, nperm = 1000, ncores = 1, seed = 444)
print(test) # logIRR
print(exp(test['spnvac'])) # IRR
```
The `formula`, `family`, and `data` arguments are passed to the corresponding regression function, `stats::glm`; `trtname` specifies the column name of the randomized treatment variable and `runit` specifies the column name of the unit of randomization identifier (e.g. cluster id); `nperm` specifies the number of permutations used for the Monte Carlo approximation of the exact p-value (Dwass, 1957). To speed up compuation, we could instead specify `ncores` > 1 to run the randomization test in parallel across multiple cores. Finally, the `seed` argument is passed to `set.seed` (if `ncores` = 1) or `doRNG::registerDoRNG` (if `ncores` > 1) to make results reproduceable.

We get an estimated IRR of 0.64 (logIRR = -0.45) with a p-value of 0.078.

#### Randomization-based CI
Now, let's get the corresponding randomization-based 95% CI using `permci_glm`:
```{r, pci, warning = F, message = F}
ci <- permci_glm(formula = bpepisodes ~ spnvac, 
                 trtname = 'spnvac', runit = 'randunit', family = poisson, 
                 data = pneumovac, nperm = 1000, ncores = 2, seed = 445,
                 level = 0.95, initmethod = 'perm')
print(ci$ci) # logIRR
print(exp(ci$ci)) # IRR
```
Most of the arguments are the same except the additional specification of the confidence `level` (95% here) and `initmethod`, which specifies the method to obtain initial values for the CI procedure (see `permci_glm` documentation for more detail). The efficient CI procedure used in the **permuter** package was proposed by Garthwaite (1996) and is based on the Robbins-Monro search process. If `ncores` > 1 for `permci_glm` (or another CI function), lower and upper bound search procedures run in parallel across two cores (but not more than two).

We get a 95% CI for the IRR of 0.37 to 1.06 (rounding conservatively).

We can inspect convergence of the CI procedure using values stored in `ci$trace`:
```{r, fig.show = 'hold'}
plot(ci$trace[, 1], type = 'l', las = 1, main = 'Lower bound', 
     xlab = 'Number of Permutations', ylab = 'log(IRR)')
plot(ci$trace[, 2], type = 'l', las = 1, main = 'Upper bound', 
     xlab = 'Number of Permutations', ylab = 'log(IRR)')
```

Note: we've used only 1,000 permutations in this example for convenience. In practice, we'll usually need to increase the number of permutations (e.g. 5,000 or 20,000) to ensure adequate approximation of the exact p-value and convergence of the CI bounds.

## Example 2: Going a Bit Deeper
This example will illustrate some of the optional arguments, e.g. `strat`, `nburn`, `init`, `initmethod`, `...`. Also a good place to illustrate some of the practical points raised in discussion like restarting the procedure if the starting values seem poor, using multiple chains with different starting values, and considering different step length constants. Maybe use `gendata_crt`.

## References
Dwass, M. (1957). Modified Randomization Tests for Nonparametric Hypotheses. *The Annals of Mathematical Statistics* **28**, 181--187.

Garthwaite, P. H. (1996). Confidence intervals from randomization tests. *Biometrics* **52**, 1387--1393.

Hayes, R. J. and Moulton, L. H. (2017). *Cluster Randomised Trials* 2nd edition. New York: Chapman and Hall/CRC.

O'Brien, K. L. et al. (2003). Efficacy and safety of seven-valent conjugate pneumococcal vaccine in American Indian children: group randomised trial. *Lancet* **362**, 355â€“361.

Rabideau, D. J., and Wang, R. (2019). Randomization inference for a marginal treatment effect in cluster randomized trials. Manuscript sumbitted for publication.
